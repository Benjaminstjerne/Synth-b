<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>Aeolian Crystal Field</title>

<style>
html,body{
margin:0;
overflow:hidden;
background:#ffffff;
touch-action:none;
}
</style>
</head>

<body>

<script src="https://cdn.jsdelivr.net/npm/three@0.160/build/three.min.js"></script>

<script>

//////////////// AUDIO //////////////////

const ctx=new (window.AudioContext||webkitAudioContext)();
const master=ctx.createGain();
master.gain.value=.4;
master.connect(ctx.destination);

// harmonic windchime ratios
const field=[1,5/4,3/2,2,5/3,9/8];

function chime(freq,energy){

let count=3+Math.floor(Math.random()*3);

for(let i=0;i<count;i++){

const o=ctx.createOscillator();
const g=ctx.createGain();

o.type="sine";

let ratio=field[Math.floor(Math.random()*field.length)];
let detune=(Math.random()<.12)?(Math.random()-.5)*15:0;

o.frequency.value=freq*ratio;
o.detune.value=detune;

o.connect(g);
g.connect(master);

let now=ctx.currentTime;
let dur=2+energy*4;

g.gain.setValueAtTime(0,now);
g.gain.linearRampToValueAtTime(.3/(i+1),now+.3);
g.gain.exponentialRampToValueAtTime(.0001,now+dur);

o.start();
o.stop(now+dur+1);
}
}

//////////////// THREE //////////////////

const scene=new THREE.Scene();
scene.background=new THREE.Color(0xffffff);

const camera=new THREE.PerspectiveCamera(55,innerWidth/innerHeight,.1,100);
camera.position.z=4;

const renderer=new THREE.WebGLRenderer({antialias:true});
renderer.setSize(innerWidth,innerHeight);
document.body.appendChild(renderer.domElement);

const geo=new THREE.IcosahedronGeometry(1,5);
const base=geo.attributes.position.array.slice();

const mat=new THREE.MeshPhysicalMaterial({
color:0xffffff,
roughness:.08,
transmission:.85,
thickness:.6,
clearcoat:1
});

const mesh=new THREE.Mesh(geo,mat);
scene.add(mesh);

scene.add(new THREE.DirectionalLight(0xffffff,2));
scene.add(new THREE.AmbientLight(0xffffff,1));

//////////////// INTERACTION //////////////////

let motion=0;
let target={x:.5,y:.5,z:0};
let smooth={x:.5,y:.5,z:0};

function lerp(a,b,t){return a+(b-a)*t;}

function resume(){
ctx.resume();
}

addEventListener("pointerdown",resume);
addEventListener("touchstart",resume);

if(DeviceMotionEvent){
DeviceMotionEvent.requestPermission?.().catch(()=>{});
addEventListener("devicemotion",e=>{
if(e.accelerationIncludingGravity){
motion+=Math.abs(e.accelerationIncludingGravity.x||0)*.015;
motion+=Math.abs(e.accelerationIncludingGravity.y||0)*.015;
motion+=Math.abs(e.accelerationIncludingGravity.z||0)*.015;

target.x+=(e.rotationRate?.gamma||0)*.0003;
target.y+=(e.rotationRate?.beta||0)*.0003;
target.z=(e.accelerationIncludingGravity.z||0)*.002;
}
});
}

addEventListener("pointermove",e=>{
target.x=e.clientX/innerWidth;
target.y=1-e.clientY/innerHeight;
});

// fullscreen

function fullscreen(){
if(!document.fullscreenElement){
document.documentElement.requestFullscreen();
}
}

addEventListener("pointerup",fullscreen);

//////////////// LOOP //////////////////

let last=0;

function animate(t){

requestAnimationFrame(animate);

smooth.x=lerp(smooth.x,target.x,.02);
smooth.y=lerp(smooth.y,target.y,.02);
smooth.z=lerp(smooth.z,target.z,.02);

motion*=.97;

let chaos=motion+Math.abs(smooth.z);

// organic deformation

let pos=geo.attributes.position.array;
for(let i=0;i<pos.length;i++){
let wob=Math.sin(t*.001+i)*.05*chaos;
pos[i]=base[i]*(1+wob);
}
geo.attributes.position.needsUpdate=true;

mesh.rotation.x+=.001+smooth.y*.01;
mesh.rotation.y+=.001+smooth.x*.01;

mesh.scale.setScalar(1+.1*Math.sin(t*.001)+chaos*.2);

// slower sound triggers

let now=performance.now();
if(motion>.4 && now-last>1200){

last=now;

let root=180+smooth.y*300;
chime(root,chaos);

motion=0;
}

renderer.render(scene,camera);
}

animate();

</script>
</body>
</html>
